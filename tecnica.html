<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Matchmaking — Parte Técnica</title>
<link rel="stylesheet" href="css/tecnica.css">
</head>
<body>
<header class="header">
  <div class="nav-wrapper container">
    <div class="logo">Matchmaking — Dossiê Clash Royale</div>
    <nav class="nav-links">
      <a class="nav-link" href="index.html">Home</a>
      <a class="nav-link active" href="tecnica.html">Técnica</a>
      <a class="nav-link" href="psicologia.html">Psicologia</a>
      <a class="nav-link" href="conclusao.html">Conclusão</a>
      <a class="nav-link" href="investigadores.html">Investigadores</a>
    </nav>
  </div>
</header>

<main class="container">
  <section class="hero">
    <h1>Parte Técnica — A Engenharia do Sistema</h1>
    <p>Esta página explica, em linguagem simples, como funciona o sistema técnico de matchmaking e todos os seus blocos importantes. Ao final você terá: a arquitetura essencial, o passo-a-passo do pipeline, um algoritmo explicativo (pseudocódigo simples), noções matemáticas, problemas práticos, DER conceitual e mockups anotados.</p>
  </section>

  <!-- Card: Arquitetura -->
  <section class="section">
    <article class="card">
      <h2>6.1 — Arquitetura técnica (visão geral)</h2>
      <p>Pense no sistema de matchmaking como uma linha de montagem com várias etapas — cada uma com uma função bem definida. Aqui estão os blocos principais, explicados de forma simples:</p>
      <ul>
        <li><strong>Cliente (jogador)</strong> — quando o jogador clica em “Jogar”, o app envia um ticket com informações básicas: PlayerID, modo, ping, party_id e snapshot do MMR/trophies.</li>
        <li><strong>Validador / Gateway</strong> — checa coisas rápidas: jogador está banido? está no modo correto? ping tolerável?</li>
        <li><strong>Fila distribuída (Queue)</strong> — o ticket entra em buckets por região e modo.</li>
        <li><strong>Matcher</strong> — o cérebro que pega tickets e tenta formar partidas. Usa janelas de MMR e regras de party/duo.</li>
        <li><strong>Score de Qualidade (MQS)</strong> — para cada combinação calcula um score que representa “quão boa” é a partida.</li>
        <li><strong>Alocador de servidores</strong> — seleciona servidor com menor latência média e disponibilidade.</li>
        <li><strong>Orquestrador</strong> — cria a partida no servidor, avisa os jogadores e, no fim, atualiza dados (MMR, logs).</li>
      </ul>
      <p>Resumo visual: abaixo há um espaço para você colocar o fluxograma completo que descreve os 12 passos do processo.</p>
      <p>[IMAGEM: Fluxograma do Matchmaking]</p>
      <img class="placeholder" src="assets/fluxograma.png" alt="Fluxograma do Matchmaking">
    </article>
  </section>

  <!-- Card: Pipeline -->
  <section class="section">
    <article class="card">
      <h2>6.2 — Pipeline completo do matchmaking (passo a passo)</h2>
      <p>Descrição sequencial do que acontece no sistema:</p>
      <ol>
        <li><strong>Entrada do Ticket:</strong> o cliente envia PlayerID, modo, ping, party_id, mmr_snapshot e time_created.</li>
        <li><strong>Validação rápida:</strong> checagens de penalidade/ping/modo.</li>
        <li><strong>Inserção em fila:</strong> ticket cai em bucket por região e modo.</li>
        <li><strong>Busca inicial (janela MMR pequena):</strong> ex.: ±25 em torno do MMR.</li>
        <li><strong>Se não encontrar:</strong> amplia a janela (±50, ±100) após alguns segundos.</li>
        <li><strong>Formação de grupos compatíveis:</strong> respeita parties, roles e limites do modo.</li>
        <li><strong>Geração de combinações e cálculo do MQS:</strong> cada combinação recebe um score.</li>
        <li><strong>Seleção da melhor combinação:</strong> que atenda requisitos de ping e MQS mínimo.</li>
        <li><strong>Alocação do servidor:</strong> servidor próximo e com capacidade.</li>
        <li><strong>Confirmação com jogadores:</strong> se algum recusa/disconecta, tickets retornam à fila.</li>
        <li><strong>Início da partida</strong>.</li>
        <li><strong>Pós-jogo:</strong> atualizar MMR, logs, executar detecções (smurf/afk), armazenar estatísticas.</li>
      </ol>
    </article>
  </section>

  <!-- Card: Algoritmo -->
  <section class="section">
    <article class="card">
      <h2>6.3 — Algoritmo de formação de times (pseudocódigo)</h2>
      <pre>
1. pegar tickets na fila (bucket de mesma região e modo)
2. ordenar tickets por tempo de espera (quem está há mais tempo tem prioridade)
3. para cada ticket 'A' na lista:
     procurar candidatos B, C, ... dentro da janela atual de MMR
     formar combinações possíveis (ex.: pares para 1v1, quartetos para 2v2)
     calcular MQS para cada combinação
     se alguma combinação tiver MQS >= threshold:
         reservar os tickets (remover da fila)
         notificar jogadores ("Match found")
         alocar servidor e criar a partida
         sair do loop para não usar esses tickets novamente
4. se não encontrar combinação:
     esperar X segundos e aumentar a janela de MMR
     repetir processo
      </pre>
      <p>Explicação: o sistema prioriza quem está esperando há mais tempo (para evitar starvation). Caso não ache parceiros similares, aumenta a tolerância para reduzir o tempo de fila.</p>
    </article>
  </section>

  <!-- Card: MQS & Janelas -->
  <section class="section">
    <article class="card">
      <h2>6.4 — Match Quality Score (MQS) e Janelas de MMR</h2>
      <p>O MQS é um número que indica “quão boa” é essa partida potencial. Ele mistura fatores como diferença de habilidade, latência média, tamanho de parties, risco de smurf, e tempo de fila (bônus para quem espera muito).</p>
      <p>Fórmula didática (exemplo):</p>
       <img class="placeholder" src="assets/formula.png" alt="formula">
      <p>Janelas de MMR (estratégia típica):</p>
      <ul>
        <li>Janela inicial: ±25</li>
        <li>Após 10–20s: ±50</li>
        <li>Após 30–60s: ±100</li>
        <li>Depois disso: expandir somente se necessário</li>
      </ul>
      <p>Motivo: manter a janela pequena produz partidas mais equilibradas; ampliar reduz tempo de espera em pools escassos.</p>
    </article>
  </section>

  <!-- Card: Matemática & Smurfs -->
  <section class="section">
    <article class="card">
      <h2>7 — Matemática do Matchmaking & Detecção de Smurfs (resumo)</h2>
      <h3>7.1 — Conceitos essenciais</h3>
      <p>Elo/MMR: números que representam habilidade estimada.</p>
      <p>Incerteza (sigma): contas novas têm alta incerteza, sistemas como Glicko usam sigma para ajustar a confiança.</p>
      <p>Probabilidade de vitória: dada a diferença de MMR, estimamos chance de vencer — isso alimenta alterações de MMR.</p>

      <h3>7.2 — Detecção de smurfs (estratégias práticas)</h3>
      <ul>
        <li>Idade da conta + velocidade de subida de troféus — sinais fortes.</li>
        <li>Performance anormal (consistência além do razoável) — análise estatística.</li>
        <li>Padrões de IP/dispositivo — múltiplas contas relacionadas.</li>
        <li>Score de smurfRisk agregado; se alto, medidas como pools separados ou shadow pool.</li>
      </ul>
    </article>
  </section>

  <!-- Card: Problemas e mitigação -->
  <section class="section">
    <article class="card">
      <h2>8 — Problemas do Matchmaking e abordagens</h2>
      <ul>
        <li><strong>Smurfs</strong> — detectar com smurfRisk e colocar em pool especial.</li>
        <li><strong>Boosting</strong> — detectar padrões e auditar manualmente.</li>
        <li><strong>Toxicidade / AFK</strong> — penalidades automáticas, reputação reduzida.</li>
        <li><strong>Fila longa</strong> — expandir janela progressivamente, oferecer modos alternativos.</li>
        <li><strong>Variância</strong> — considerar MMR por performance além de vitória/derrota.</li>
        <li><strong>Duos / parties</strong> — ajustar MQS para compensar vantagem de coordenação.</li>
      </ul>
    </article>
  </section>

  <!-- Card: DER conceitual -->
  <section class="section">
    <article class="card">
      <h2>14 — MODELO DE DADOS (DER Conceitual)</h2>
      <p>Entidades principais para modelagem de dados:</p>
      <ul>
        <li><strong>Player</strong> — id, nickname, região, plataforma, status.</li>
        <li><strong>Player_MMR</strong> — histórico por modo (player_id, mode, mmr_value, mmr_sigma).</li>
        <li><strong>Queue_Ticket</strong> — ticket_id, player_id, party_id, mode, mmr_snapshot, time_created, status.</li>
        <li><strong>Party</strong> — party_id, owner_id, size.</li>
        <li><strong>Party_Members</strong> — relacionamento Party ↔ Player.</li>
        <li><strong>Match</strong> — match_id, mode, start_time, server_id, match_quality_score.</li>
        <li><strong>Match_Players</strong> — associação Match ↔ Player com time, resultado e estatísticas.</li>
      </ul>
      <p>Relacionamentos principais:</p>
      <ul>
        <li>Player 1 — N Player_MMR</li>
        <li>Player 1 — N Queue_Ticket</li>
        <li>Party N — N Player (via Party_Members)</li>
        <li>Match N — N Player (via Match_Players)</li>
        <li>Party 1 — N Queue_Ticket</li>
      </ul>
      <p>[IMAGEM: DER conceitual aqui]</p>
      <img class="placeholder" src="assets/der.png" alt="DER conceitual">
    </article>
  </section>

  <!-- Card: Mockups anotados -->
  <section class="section">
    <article class="card">
      <h2>15 — Mockups do Sistema (anotados)</h2>
      <p>As telas que você deve produzir com base nesses dados:</p>

      <h3>Tela 1 — Lobby / Fila</h3>
      <p>Conteúdo a mostrar: Player.nickname, Queue_Ticket.role_escolhida, leitura de ping, Queue_Ticket.tempo_entrada, Player_MMR.mmr_atual, botões Cancelar/Ver Regras, tempo estimado e janela atual (±25 MMR).</p>
      <p>[IMAGEM: Mockup — Lobby/ Fila aqui]</p>
      <img class="placeholder" src="assets/mockup_lobby.png" alt="Mockup Lobby">

      <h3>Tela 2 — Pré-partida</h3>
      <p>Conteúdo a mostrar: Lista de jogadores (Match_Players + Player), Time A/B, Roles, Qualidade da partida (Match.match_quality_score), servidor e botões aceitar/recusar.</p>
      <p>[IMAGEM: Mockup — Pré-partida aqui]</p>
      <img class="placeholder" src="assets/mockup_pre.png" alt="Mockup Pré-partida">

      <h3>Tela 3 — Pós-partida</h3>
      <p>Conteúdo a mostrar: Resultado (Match_Players.resultado), MMR ganho/perdido, estatísticas (Match_Players.desempenho), botão Reportar e Ver Replay.</p>
      <p>[IMAGEM: Mockup — Pós-partida aqui]</p>
      <img class="placeholder" src="assets/mockup_post.png" alt="Mockup Pós-partida">
    </article>
  </section>

  <footer class="footer">
    <div>Matchmaking — Parte Técnica • Dossiê Clash Royale</div>
  </footer>
</main>
</body>
</html>
